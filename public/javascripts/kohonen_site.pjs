/* @pjs transparent=true; */
// ---------------------------------------------------------------- //
//  Kerning Pairs Visualizator
//  2005 Martin Bereciartua - email (at) m-i-b.com.ar
//  http://www.m-i-b.com.ar/
// ---------------------------------------------------------------- //
//
//  This source is released under the creative commons license 
//  http://creativecommons.org/licenses/by-nc-sa/1.0/
//
//  Thanks to:
//  Ben Fry and Karsten Schmidt for inspiration
//
// ---------------------------------------------------------------- //
//  Made with Processing (Beta) v091
// ---------------------------------------------------------------- //
//  Modificado por Vinícius Alves Oyama

int nro_linea = 2;
int nro_espacio = 0;
PFont font;

int total_de_vetores = 0;
float k_total;

int espacio_abajo;
int espacio_arriba;
int espacio_derecha;
int espacio_izquierda;

int burbujas_maximas = 1000;
int burbujas_graficadas = 0;

Ball[] balls = new Ball[0];
Perfil[] perfis = new Perfil[0];

int lapso_refresh = 1;               // cada cuantos frames se renueva la info del listado
int timer_interno = 0;


void setup() {

  size(650,650);
  background(0, 0, 0, 0);
  smooth();
  loop();  
   
  font = loadFont("Century.vlw");
  
  layout();

}

void layout() {

	
  // datos
  textFont(font, 14);
  textAlign(CENTER);
  fill(5);
  text("Mostrando " + str(burbujas_graficadas)+" neuronios do total de "+str(balls.length), width/2, height-30);

}

void draw() {

    // refrescar orden de la info    
      timer_interno++;
      if ( timer_interno == lapso_refresh ) {
        timer_interno = 0;
		//temos que reordenar o array pois o desenho das bordas do neuronio depende do numero de ocorrencias maximo e minimo entre todos os neuronios
        //e essa informação é retirada baseando-se na ideia de que o array de neuronios esta ordenado
		MapaNeural.ordenarArrayDeNeuronios();
      }
    
    background(0, 0, 0, 0);
    
    total_de_vetores = 0;
    burbujas_graficadas = 0;
    for ( int i=burbujas_maximas; i>=0; i-- ) {
      if ( i < balls.length ) {
        total_de_vetores += balls[i].ocurrencias;
        burbujas_graficadas++;
      }
    }
    
    MapaNeural.calcularAreaTotalASerOcupadaPeloQuadradoDoNeuronio();
	if (MapaNeural.ativarEfeitoVisualDeAcordoComNumeroDeVetores)
    for ( int i=0; i<balls.length; i++ ) {
      float kprima = ( k_total * balls[i].ocurrencias ) / balls[0].ocurrencias;
      balls[i].ka = kprima;
      balls[i].r = sqrt( ( ( kprima ) / PI ) );
    }
        
    for ( int i=burbujas_maximas; i>=0; i-- ) {
      if ( i < balls.length ) {
        balls[i].encima();      
        balls[i].display();
      }
    }

	MapaDePerfis.desenharPerfis();

}


public class MapaNeural {
	public boolean ativarEfeitoVisualDeAcordoComNumeroDeVetores = false;
	public static int quantidadeDeLinhas = 3;
	
	public static int quantidadeDeColunas = 3;
	
	//Adiciona um vetor a um neuronio, caso o neuronio não exista ele é criado
	public static void adicionarVetorAUmNeuronio( String idNeuronio, String vetor ) {
	  Ball neuronio = MapaNeural.obterNeuronioPorId(idNeuronio);
	
	  if (neuronio == null)	{
			alert('Atencao. Nao foi possivel adicionar o vetor ' + vetor + ' ao neuronio de id ' + idNeuronio + '. Pois nao foi encontrado um neuronio com esse id');
			return;
	  } else
		neuronio.adicionarVetor(vetor);
	}

	public static Ball criarNeuronio( String idNeuronio, String vetor, int linhaDoNeuronio, int colunaDoNeuronio, int ocorrencias) {  
		
		if (MapaNeural.atingiuNumeroMaximoDeNeuroniosPermitidos()) {
			alert('Atencao. Nao e possivel criar o neuronio ' + idNeuronio + ' pois ja foi atingido o numero maximo de neuronios da rede.');
			return;
		}
		
		Ball neuronio = MapaNeural.obterNeuronioPorId(idNeuronio);
		if (neuronio != null){
			alert('Atencao. Nao e possivel criar o neuronio ' + idNeuronio + ' pois ja existe um neuronio com esse id na rede');
			return;
		}
			
		MapaNeural.calcularAreaTotalASerOcupadaPeloQuadradoDoNeuronio();
			
		Ball[] tempBall = new Ball( idNeuronio, k_total, "Nome", vetor, MapaNeural.obterPontoDoNeuronioDadaALinhaEColuna(linhaDoNeuronio,colunaDoNeuronio) , ocorrencias);
		balls[balls.length] = tempBall;
		
		return tempBall;
	}
	
	private static Ball obterNeuronioPorId(String idNeuronio) {
		Ball neuronio = null;
		  // buscar kp a sumar en array existente
		  for (int i=0; i < balls.length; i++) { 
		    if ( balls[i].id == idNeuronio) {
		      neuronio = balls[i];
		    } 
		    if (neuronio != null) break;
		  }
		return neuronio;
	}

	private static boolean atingiuNumeroMaximoDeNeuroniosPermitidos() {
		return (MapaNeural.numeroMaximoDeNeuronios() <= balls.length)
	}

	public static Ponto obterPontoDoNeuronioDadaALinhaEColuna(int linha, int coluna) {
		float larguraDoQuadradoDeCadaNeuronio =  (float)width/(float)MapaNeural.quantidadeDeColunas;
		float alturaDoQuadradoDeCadaNeuronio =  (float)height/(float)MapaNeural.quantidadeDeLinhas;
		float x = (float)coluna*larguraDoQuadradoDeCadaNeuronio + larguraDoQuadradoDeCadaNeuronio/2.0;
		float y = (float)linha*alturaDoQuadradoDeCadaNeuronio + alturaDoQuadradoDeCadaNeuronio/2.0;
				
		return new Ponto(x,y);
	}
	//ordena o array de neuronio de acordo com o numero de ocorrencias de vetores de cada um
	// a posição zero do array é ocupada pelo neuronio que possui mais ocorrencias de vetores
	public static void ordenarArrayDeNeuronios() {

	  Ball[] temp_ocurrencias = new Ball[balls.length];
	  temp_ocurrencias = balls;

	  Ball temp;
	  int i, j;

	  for (i = temp_ocurrencias.length-1; i >= 0; i--)
	       for (j = 0; j < i; j++)
	          if (temp_ocurrencias[j].ocurrencias < temp_ocurrencias[j + 1].ocurrencias) {
	             temp = temp_ocurrencias[j];
	             temp_ocurrencias[j] = temp_ocurrencias[j + 1];
	             temp_ocurrencias[j + 1] = temp;
	          }

	  balls = temp_ocurrencias;

	}

	public static void calcularAreaTotalASerOcupadaPeloQuadradoDoNeuronio() {
		
		float larguraDoRetanguloDeCadaNeuronio =  (float)width/(float)MapaNeural.quantidadeDeColunas;
		float alturaDoRetanguloDeCadaNeuronio =  (float)height/(float)MapaNeural.quantidadeDeLinhas;
		
		//caso o mapa nao possuia o mesmo numero de colunas e linhas para facilitar o calculo
		// nos consideramos que ele é simetrico utilizando o maior entre as duas dimensoes
		//area da cinrcunferencia inscrita em um quadrado
		
		if (larguraDoRetanguloDeCadaNeuronio > alturaDoRetanguloDeCadaNeuronio)
			k_total = alturaDoRetanguloDeCadaNeuronio*alturaDoRetanguloDeCadaNeuronio*PI/4.0;
		else
			k_total = larguraDoRetanguloDeCadaNeuronio*larguraDoRetanguloDeCadaNeuronio*PI/4.0;
	}
	
	public static int numeroMaximoDeNeuronios() {
		return MapaNeural.quantidadeDeLinhas * MapaNeural.quantidadeDeColunas;
	}
}

public class MapaDePerfis {
	public static boolean deveDesenharOsPerfis = false;
	public static void desenharPerfis() {
		if (MapaDePerfis.deveDesenharOsPerfis)
			for(int indicePerfis=0; indicePerfis < perfis.length; indicePerfis++) { 
				perfis[indicePerfis].display();
			}
	}
	
	public static void adicionarPerfil(int x, int y, float radius, int ocorrencias) {
		Perfil novoPerfil = new Perfil(MapaNeural.obterPontoDoNeuronioDadaALinhaEColuna(x,y), radius, ocorrencias);
		perfis[perfis.length] = novoPerfil;
	}
}
/*****************************
EVENTOS
******************************/

void mouseClicked() {
	/*
	for(int indiceNeuronios=0; indiceNeuronios < balls.length; indiceNeuronios++) { 
		if(balls[indiceNeuronios].estamos_encima) {
			Ball neuronio = balls[indiceNeuronios];
			cliqueNoNeuronio(neuronio);
		}
	}*/
}

/******************************
CLASSES
******************************/
class Ponto {
	public float x;
	public float y;
	
	Ponto(float _x, float _y) {
		this.x = _x;
		this.y = _y;
	}
	
}

class Perfil {
	
	public float x;
	public float y;
	public float raio;
	public int ocorrencias;
	
	Perfil(Ponto centroDoCirculo, float _raio, int _ocorrencias) {

		this.x = centroDoCirculo.x;
		this.y = centroDoCirculo.y;
		this.raio = _raio;
		this.ocorrencias = _ocorrencias;
	}
	
	public void display() {
		
		r = sqrt( k_total / PI );
		r = r*2.0*raio;
		
		noFill();
	    
		fill(10,10,10,30);

	    strokeWeight(r/150);

	    color local = color(0,0,0);
	    stroke( local );

		//desenha o circulo  
	    ellipse(this.x,this.y,2*r-r/10,2*r-r/10); 
		noFill();
		noStroke();
		fill(255);
		strokeWeight(0);
		
		rect(this.x - 14 , this.y - 15, 30, 20);

	    textFont(font, 12);
	    textAlign(CENTER);
	
	    fill(0,0,0);

	    text(this.ocorrencias, this.x, this.y);
	}
}

class Ball {

  public static int NumeroNeuronios = 0;
  
  float r;
  
  public float x;
  public float y;
  
  public String id;
  float ka;
  
  String nombre;
  String[] vetores = new String[0];
  int ocurrencias = 0;
  
  boolean estamos_encima;
  
  Ball( String ID, float areaAOcupar, String NOMBRE, String vetor , Ponto centroDoCirculo, int _ocorrencias) {
    NumeroNeuronios++;
    ka = areaAOcupar;
    r = sqrt( ka / PI );
    x = centroDoCirculo.x;
    y = centroDoCirculo.y;
	this.ocurrencias = _ocorrencias;
	
    id = ID;
    nombre = NOMBRE;
    
 	for(int i=0;i < _ocorrencias; i++)
		this.adicionarVetor('');
  }
  
  void encima() {
	
    if ( dist(x, y, mouseX, mouseY) < r ) {
		estamos_encima = true;
	} 
	else  
		estamos_encima = false;
  }
  
  void display() {
  
	//guarda o numero maximo, minimo de ocorrencia de vetores entre todos os neuronios e tambem armazena o numero de ocorrencias do neuronio atual
    float A = balls[0].ocurrencias;                        // maximo original
    float C = ocurrencias;                                 // valor original
    float B = balls[burbujas_graficadas-1].ocurrencias;    // minimo original
    float D;                                               // nuevo maximo
    float E;                                               // nuevo minimo

    noFill();
    if ( estamos_encima ) 
		fill(0,0,0,15);
	else
	    fill(255);
	
    strokeWeight(r/20);
	
	float lc = 100;
	float lcalpha = 255;
	
	if (MapaNeural.ativarEfeitoVisualDeAcordoComNumeroDeVetores) {
		//configura a transparencia e a cor da borda dependendo do numero de ocorrencia de vetores
	    lc = -1 * ( ( ( A - C ) / ( A - B ) ) * ( 60 - 200 ) - 60 );
	    lcalpha = -1 * ( ( ( A - C ) / ( A - B ) ) * ( 255 - 90 ) - 255 );

	    if ( A == B ) lcalpha = 255;
	}
	
	if (isNaN(lc))
		lc=0;
		
    color local = color( lc );
    stroke( local );
	
	//desenha o circulo  
    ellipse(x,y,2*r-r/10,2*r-r/10); 
    float tamanio = r*0.8;
    textFont(font, tamanio);
    textAlign(CENTER);
    fill(220, 112, 23, lcalpha);

    text(this.id, x, y+tamanio/5);

    float tamanio1 = r*0.45;
    textFont(font, tamanio1);
    fill(0, 102, 153, lcalpha);
    text(str(ocurrencias), x, y+tamanio/3+tamanio1);

  }
  
  void adicionarVetor( String vetor ) {
    vetores[vetores.length] = vetor;
	ocurrencias = vetores.length; 
	heatMap.store.addDataPoint(this.x, this.y);
  }
}



